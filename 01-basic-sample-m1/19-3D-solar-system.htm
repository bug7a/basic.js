<!DOCTYPE html>
<html lang="en">

<head>

    <title>Sample 2 - Solar System 3D</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- LIBRARY FILES -->
    <link rel="preload" href="../basic/font/open-sans/OpenSans-Regular.ttf" as="font" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="../basic/basic.min.css">
    <script src="../basic/basic.min.js" type="text/javascript" charset="utf-8"></script>

    <script>

        // VARIABLES
        let sun;
        let planets = [];

        // Planet data
        // dist: Average distance (radius)
        // size: Base size
        // speed: Orbital speed
        // color: Planet color
        // angle: Starting angle
        const planetData = [
            { dist: 90, size: 12, speed: 0.04, color: "#A6A6A6", angle: 0 },   // Mercury
            { dist: 130, size: 20, speed: 0.025, color: "#E2C396", angle: 1 }, // Venus
            { dist: 180, size: 22, speed: 0.02, color: "#4A90E2", angle: 2 },  // Earth
            { dist: 230, size: 16, speed: 0.015, color: "#E57373", angle: 3 }, // Mars
            { dist: 320, size: 45, speed: 0.008, color: "#D4A373", angle: 4 }, // Jupiter
            { dist: 400, size: 38, speed: 0.006, color: "#F4E1A1", angle: 5 }  // Saturn
        ];

        window.onload = function () {

            basic.start();
            page.color = "#0B0B15"; // Deep space dark

            // Create Stars Background
            for (let i = 0; i < 80; i++) {
                const size = random(1, 3);
                const star = Box(random(0, page.width), random(0, page.height), size, size, {
                    color: "white",
                    opacity: random(2, 8) / 10,
                    round: size
                });
            }

            // SUN
            // We give it a z-index of 100 so planets can go behind (z<100) or in front (z>100)
            sun = Box(0, 0, 80, 80, {
                color: "#FFD700",
                round: 50,
            });
            that.center();
            that.elem.style.boxShadow = "0 0 50px rgba(255, 215, 0, 0.5)";
            that.elem.style.zIndex = 100;

            // Create Planets
            for (let i = 0; i < planetData.length; i++) {
                const p = planetData[i];

                // Orbit Path (Elliptical visual guide)
                // We use a flattened circle to represent the orbit path
                const orbitWidth = p.dist * 2;
                const orbitHeight = p.dist * 2 * 0.3; // 0.3 is the tilt factor

                const orbit = Box(0, 0, orbitWidth, orbitHeight, {
                    color: "transparent",
                    border: 1,
                    borderColor: "rgba(255, 255, 255, 0.08)",
                    // round: 1000 // REMOVED: This creates rounded rects for non-square boxes
                });
                that.center();
                that.clickable = 0;
                that.elem.style.zIndex = 50;
                that.elem.style.borderRadius = "50%"; // FIX: Use 50% for true ellipse

                // Planet Object
                const planet = Box(0, 0, p.size, p.size, {
                    color: p.color,
                    round: 50
                });
                // Add shadow/shading
                that.elem.style.boxShadow = "inset -3px -3px 8px rgba(0,0,0,0.6)";

                p.obj = planet;
                p.baseSize = p.size; // Remember base size for scaling
                planets.push(p);
            }

            // Start Animation Loop
            setLoopTimer(16); // ~60 FPS

        };

        const loop = function () {

            const centerX = page.width / 2;
            const centerY = page.height / 2;
            const tiltFactor = 0.3; // How flat the ellipse is

            for (let i = 0; i < planets.length; i++) {
                const p = planets[i];

                // Update angle
                p.angle += p.speed;

                // 3D Position Math
                // x: Horizontal position
                // y: Vertical position (flattened by tilt)
                // z: Depth (used for scale and z-index)

                const x = Math.cos(p.angle) * p.dist;
                const z = Math.sin(p.angle) * p.dist; // Depth: positive is "close", negative is "far"
                const y = z * tiltFactor; // Visual Y position

                // Scale calculation
                // When z is positive (close), scale up. When negative (far), scale down.
                // Normalize z from [-dist, dist] to scale factor
                const scaleFactor = 1 + (z / p.dist) * 0.3; // Scale varies by +/- 30%

                // Apply Scale
                const currentSize = p.baseSize * scaleFactor;
                p.obj.width = currentSize;
                p.obj.height = currentSize;
                p.obj.round = currentSize; // Keep it circular

                // Position
                // Center the planet object based on its new size
                p.obj.left = centerX + x - (currentSize / 2);
                p.obj.top = centerY + y - (currentSize / 2);

                // Z-Index
                // Sun is 100.
                // If z > 0 (front), zIndex > 100.
                // If z < 0 (back), zIndex < 100.
                if (z > 0) {
                    p.obj.elem.style.zIndex = 110 + i; // In front of Sun
                } else {
                    p.obj.elem.style.zIndex = 90 - i; // Behind Sun
                }

                // Optional: Adjust brightness based on depth
                // p.obj.opacity = 0.5 + (scaleFactor * 0.5); 
            }

        };

    </script>

</head>

<body>

    <!-- HTML content -->

</body>

</html>